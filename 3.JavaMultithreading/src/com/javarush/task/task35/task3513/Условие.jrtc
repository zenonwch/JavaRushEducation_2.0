taskKey="com.javarush.task.task35.task3513.big09"

2048 (9)

Ты отлично справляешься! Так хорошо, что я решил тебе немного помочь и уже реализовал класс View.
Он достаточно прост. Наследуемся от класса JPanel, переопределяем метод paint и выводим на экран
текущее состояние модели, полученное через контроллер.

Тебе же, предстоит закончить реализацию класса Controller.

Для начала нам понадобится конструктор, он будет принимать один параметр типа Model, инициализировать поле
model, а также сохранять в поле view новый объект типа View с текущим контроллером(this) в качестве параметра
конструктора.

Далее, нам нужен метод resetGame, который позволит вернуть игровое поле в начальное состояние.
Необходимо обнулить счет, установить флаги isGameWon и isGameLost у представления в false и вызывать метод
resetGameTiles у модели.

Добавим приватную константу int WINNING_TILE = 2048. Она будет определять вес плитки при достижении которого
игра будет считаться выигранной.

Ну а теперь, самое главное! Для того чтобы иметь возможность обрабатывать пользовательский ввод, необходимо
переопределить метод keyPressed с одним параметром типа KeyEvent.
Логика метода должна быть следующей:
1) Если была нажата клавиша ESC - вызови метод resetGame.
2) Если метод canMove модели возвращает false - установи флаг isGameLost в true.
3) Если оба флага isGameLost и isGameWon равны false - обработай варианты движения:
а) для клавиши KeyEvent.VK_LEFT вызови метод left у модели;
б) для клавиши KeyEvent.VK_RIGHT вызови метод right у модели;
в) для клавиши KeyEvent.VK_UP вызови метод up у модели;
г) для клавиши KeyEvent.VK_DOWN вызови метод down у модели.
4) Если поле maxTile у модели стало равно WINNING_TILE, установи флаг isGameWon в true.
5) В самом конце, вызови метод repaint у view.

P.S. Для получения кода нажатой клавиши используй метод getKeyCode класса KeyEvent.


2048 (8)

Итак, модель почти готова, добавим еще пару простых методов и начнем реализацию контроллера.

В модели нам не хватает способа получить игровое поле, чтобы передать его представлению на отрисовку,
а также метода, выполнив который, можно было бы определить возможен ли ход в текущей позиции,
или нет.

Контроллер, в свою очередь, будет в основном использоваться для обработки пользовательского ввода с клавиатуры,
поэтому сделаем его наследником класса KeyAdapter.

Нам понадобятся приватные поля model и view соответствующих типов и методы getGameTiles и getScore,
возвращающие подходящие свойства модели.

По пунктам:
1. Добавь в класс Model геттер для поля gameTiles.
2. Добавь в класс Model метод canMove возвращающий true в случае, если в текущей позиции
возможно сделать ход так, чтобы состояние игрового поля изменилось. Иначе - false.
3. Сделай класс Controller потомком класса KeyAdapter.
4. Добавь в класс Controller метод getGameTiles вызывающий такой же метод у модели.
5. Добавь в класс Controller метод getScore возвращающий текущий счет (model.score).



2048 (7)

Движение влево мы реализовали, теперь необходимо реализовать методы right, up, down. Уверен, что ты с этим справишься
и без моей помощи, так что дам только одну подсказку.

Что будет, если повернуть двумерный массив на 90 градусов по часовой стрелке, сдвинуть влево, а потом еще
трижды выполнить поворот?



2048 (6)

Итак, ты реализовал сжатие и слияние плиток, что в комбинации дает нам возможность осуществить движение влево.
Отлично! Но нам нужно еще и добавлять новую плитку в случае, если после передвижения игровое поле изменилось.

Давай сделаем так:
1. Изменим метод compressTiles, чтобы он возвращал true в случае, если он вносил изменения во входящий массив,
иначе - false.
2. То же самое сделаем и для метода mergeTiles.
3. Реализуем метод left, который будет для каждой строки массива gameTiles вызывать методы compressTiles
и mergeTiles и добавлять одну плитку с помощью метода addTile в том случае, если это необходимо.
4. Метод left не должен быть приватным, т.к. вызваться он будет, помимо прочего, из класса Controller.



2048 (5)

Основными возможностями, которые мы должны реализовать, являются перемещения влево, вправо, вверх и вниз.
Если ты раньше уже играл в 2048, то знаешь, что при перемещении в одну из сторон, происходит перемещение
плиток со значениями на место пустых, а также объединение плиток одного номинала.

В качестве базового сценария рассмотрим движение влево и подумаем что же происходит, когда мы хотим выполнить
это действие.

Для каждого ряда или столбца, происходят на самом деле две вещи:
а) Сжатие плиток, таким образом, чтобы все пустые плитки были справа, т.е.
ряд {4, 2, 0, 4} становится рядом {4, 2, 4, 0}
б) Слияние плиток одного номинала, т.е. ряд {4, 4, 2, 0} становится рядом {8, 2, 0, 0}.
Обрати внимание, что ряд {4, 4, 4, 4} превратится в {8, 8, 0, 0}, а {4, 4, 4, 0} в {8, 4, 0, 0}.

Создай методы compressTiles(Tile[] tiles) и mergeTiles(Tile[] tiles), которые будут реализовывать пункты
а) и б) соответственно. Использовать мы их будем только внутри класса Model, поэтому уровень доступа сделай
максимально узким.

Также добавь поля score и maxTile типа int, которые должны хранить текущий счет и максимальный вес плитки
на игровом поле. Счет увеличивается после каждого слияния, например если текущий счет 20 и было выполнено
слияние ряда {4, 4, 4, 0}, счет должен увеличиться на 8. Уровень доступа к полям должен быть шире приватного.
Проще всего организовать обновление значений этих полей в методе mergeTiles, например так:
1) Если выполняется условие слияния плиток, проверяем является ли новое значения больше максимального и
при необходимости меняем значение поля maxTile.
2) Увеличиваем значение поля score на величину веса плитки образовавшейся в результате слияния.

P.S. Когда мы будем реализовывать методы движения, сжатие будет всегда выполнено перед слиянием, таким образом
можешь считать, что в метод mergeTiles всегда передается массив плиток без пустых в середине.



2048 (4)

Игра 2048 начинается на поле, где две плитки уже имеют какие-то начальные значения. А наше поле пока пусто :(.
Прежде чем бросаться писать код, давай подумаем как это можно было бы реализовать.

Предлагаю создать приватный метод addTile, который будет смотреть какие плитки пустуют и менять вес одной из них,
выбранной случайным образом, на 2 или 4 (на 9 двоек должна приходиться 1 четверка). Получить случайный объект из списка
можешь использовав следующее выражение: (размерСписка * случайноеЧислоОтНуляДоЕдиницы).
Также получение свободных плиток можно вынести в отдельный приватный метод getEmptyTiles, возвращающий список
свободных плиток в массиве gameTiles.

После реализации функционала добавления новых плиток, добавим в конструктор два вызова метода addTile,
выполняя начальное условие задачи.

P.S. Пожалуй стоит весь код из конструктора переместить в метод resetGameTiles, для того, чтобы при необходимости
начать новую игру, не приходилось создавать новую модель, а можно было бы просто вернуться в начальное состояние
вызвав его. Уровень доступа должен быть шире приватного.
P.P.S. Для вычисления веса новой плитки используй выражение (Math.random() < 0.9 ? 2 : 4).



2048 (3)

Займемся реализацией класса Model. Он будет ответственен за все манипуляции производимые с игровым полем.

Но чтобы как-то манипулировать игровым полем, неплохо было бы для начала его создать!

Нам понадобятся:
1. Приватная константа FIELD_WIDTH = 4, определяющая ширину игрового поля.
2. Приватный двумерный массив gameTiles состоящий из объектов класса Tile.
3. Конструктор без параметров инициализирующий игровое поле и заполняющий его пустыми плитками.



2048 (2)

В игре 2048 поле состоит из 16 плиток, каждая из которых имеет определенный вес.
Кроме веса у плитки еще будет собственный цвет и цвет текста которым будет отображаться вес плитки.
Цвета плиток находятся в диапазоне от светло-серого до красного, а цвет текста будет зависеть от цвета плитки.

Создадим класс Tile описывающий одну плитку.
В нем нам понадобятся:
1. Поле value типа int, уровень доступа по умолчанию.
2. Конструктор с параметром, инициализирующий поле value.
3. Конструктор без параметров (значение поля value должно быть равно нулю).
4. Метод isEmpty, возвращающий true в случае, если значение поля value равно 0, иначе - false.
5. Метод getFontColor, возвращающий новый цвет(объект типа Color) (0x776e65) в случае,
если вес плитки меньше 16, иначе - 0xf9f6f2.
6. Метод getTileColor, возвращающий цвет плитки в зависимости от ее веса в соответствии с
нижеприведенными значениями:
0:  (0xcdc1b4);
2:  (0xeee4da);
4:  (0xede0c8);
8:  (0xf2b179);
16:  (0xf59563);
32:  (0xf67c5f);
64:  (0xf65e3b);
128: (0xedcf72);
256: (0xedcc61);
512: (0xedc850);
1024: (0xedc53f);
2048: (0xedc22e);

для любых других значений: (0xff0000).

Вышеперечисленные методы не должны быть приватными.



2048 (1)

Привет! Надеюсь ты уже успел устать от обычных задач и с нетерпением ждешь большую!
Сегодня напишем java реализацию игры 2048. Вкратце, если ты о ней ничего не слышал, целью игры является
получение плитки номиналом 2048 на игровом поле 4х4. Подробнее можешь прочитать в википедии
https://ru.wikipedia.org/wiki/2048_(%D0%B8%D0%B3%D1%80%D0%B0)

Для начала нам понадобятся такие классы:
1. Controller - будет следить за нажатием клавиш во время игры.
2. Model - будет содержать игровую логику и хранить игровое поле.
3. View - обеспечит отображение текущего состояния игры на экран.
4. Main - будет содержать только метод main и служить точкой входа в наше приложение.

Создай их!



